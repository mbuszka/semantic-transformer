#lang racket

#|
Monadic evaluator for programming language with coalgebraic effects
and cohandlers.

-- What are algebraic effects?

They consist of an algebraic theory with operations of the form

[[ op ]]   : P x |M|^A -> |M|

where given a parameter and continuation, we return new computation.
They are a way to model computational effects.

-- What are coalgebraic effects?

They consist of a coalgebraic theory with state-passing cooperations of the form

[[ coop ]] : P x |W| -> |W| Ã— A

where given a parameter and current coalgebra (configuration), we obtain new
state of the coalgebra (new config) and a value generated by coalgebra.
They *may* be a way to model interaction with external resources. In our
implementaiton cohandlers are one-shot and tail recursive, which means
that result to which they evaluate can simply be passed to continuation. This
is an easy-to-code way of ensuring that usage of potential resources (and hence
continuations) is linear.

For more details about coeffects, see:
(1) Runners in action ~ D. Ahman, A. Bauer https://arxiv.org/abs/1910.11629
(2) https://github.com/Tomatosoup97/freak
|#

(require "../lib/idl.rkt")
(require
  (for-syntax syntax/parse
              racket/syntax))

; begin interpreter

(def fst #:atomic ([Term pair]) (match pair ({Pair l _} l)))
(def snd #:atomic ([Term pair]) (match pair ({Pair _ r} r)))

(def compose #:atomic (f g) (fun #:atomic #:name ComposeInner (v) (f (g v))))

;; -- begin Syntax --

(def-data Term
  String                                  ;; variable
  Integer                                 ;; number
  {Unit}                                  ;; unit
  {Pair Term Term}                        ;; product
  {Fst Term}                              ;; first projection
  {Snd Term}                              ;; second projection
  {Lam String Term}                       ;; lambda abstraction
  {App Term Term}                         ;; application
  {Add Term Term}                         ;; addition on numbers

  {Coeffect [String label] [Term param]}  ;; coeffect with label and param
  {Cohandle [Term body] Cohandler})       ;; cohandle { body } with handler

;; Coeffects cohandler
(def-struct
  {Cohandler            ;; single coeffect handler
  [String AlgT]         ;; (co)algebraic theory under which we operate. We use
                        ;; it to gather cohandlers under common coalgebra state.
                        ;; See usage in code or tests if still unsure.
  [String label]        ;; label of coeffect that we handle
  [String param]        ;; variable with parameter
  [String conf]         ;; variable holding current coalgebra
  [Term body]})         ;; cohandling body

;; -- end Syntax --

;; -- begin StateMonad --

;; Poor man's imitation of a state monad. We don't have an exemplary
;; implementation, as our evaluator manipulates state quite explicitly.
;; Monad actually fulfilling monadic laws probably can be defined, but
;; it was found not to be necessary.
(def-struct {StateM state value})

(def return #:atomic (v state) {StateM state v})

(def returnCurry #:atomic #:name ReturnCurry (v)
  (fun #:name ReturnCurryInner (state) {StateM state v}))

(def bind #:atomic (m f)
  (match m
    ({StateM state v} ((f v) state)))
)

(def init-state #:atomic (var) 0)

(def update-state #:atomic (state tgt val)
  (fun #:atomic #:no-defun (var)
    (match (eq? tgt var)
      (#t val)
      (#f (state var)))))

(def initial-state #:atomic (x)
  (fun #:atomic #:no-defun (var) (init-state var)))

(def evalState #:atomic (m) (match m ({StateM _ x} x)))

;; -- end StateMonad --

(def eval (env [Term term] state)
  (match term
    ([String x] (return (env x) state))
    ([Integer n] (return n state))
    ({Unit} (return {Unit} state))
    ({Lam x body}
      (let closure (fun #:name Closure (v state)
                        (eval (extend env x v) body state)))
      (return closure state))
    ({Fst p} (bind (eval env p state) (compose returnCurry fst)))
    ({Snd p} (bind (eval env p state) (compose returnCurry snd)))
    ({Pair l r}
      (let {StateM state lV} (eval env l state))
      (let {StateM state rV} (eval env r state))
      ;; We evaluate pair of terms to pair of values. Note that formall it's
      ;; still a term, ideally one should define a separate struct for result.
      (return {Pair lV rV} state))
    ({App fn arg}
      (let {StateM state fnV} (eval env fn state))
      (let {StateM state argV} (eval env arg state))
      (fnV argV state))
    ({Add n m}
      (let {StateM state nV} (eval env n state))
      (let {StateM state mV} (eval env m state))
      (return (+ nV mV) state))
      ;; You can also write this in monadic synatax but meh... without
      ;; introducing do-notation it's not really readable (but it works):
      ;; (bind (eval env n state)
      ;;       (fun (nV) (fun (state)
      ;;         (bind (eval env m state)
      ;;               (fun (mV) (returnCurry (+ nV mV))))))
      ;; ))
    ({Coeffect label p}
      (let {StateM state pV} (eval env p state))
      ((findCohandler env label) pV state)
    )
    ({Cohandle body cohandlerTerm}
      ;; Evaluate cohandler and put it into environment. It would be better to
      ;; define a separate environment for handlers, and index it not
      ;; by just labels, but rather label + algT.
      (let cohandlerF (evalCohandler env state cohandlerTerm))
      (let label (getLabel cohandlerTerm))
      (let env (extend env label cohandlerF))
      (eval env body state))
  ))

(def evalCohandler (env state [Cohandler cohandler])
  (match cohandler
    ({Cohandler algT effLabel pVar confVar body}
      (fun #:name CohandlingClosure (pVal state)
        (let envParam (extend env pVar pVal))
        (let envParamConf (extend envParam confVar (state algT)))
        ;; In actual cohandlers state == newState because coeffects may not
        ;; be invoked in cohandler's body. We omit check for it here, as
        ;; this is a part of static analysis.
        (let {StateM newState coresult} (eval envParamConf body state))
        ;; cohandler body must evaluate to a pair of next configuration and
        ;; result passed to continuation
        (let {Pair nextConf result} coresult)
        (let newState (update-state state algT nextConf))
        (return result newState)
    ))
  ))

(def findCohandler #:atomic (env label) (env label))

(def getLabel #:atomic ([Cohandler cohandler])
  (match cohandler ({Cohandler _ label _ _ _} label)))

;; -- begin Environment --

(def initial-env #:atomic (x) (error "Empty env!"))

(def extend #:atomic (env k v)
  (fun #:atomic #:name Extend #:apply lookup (x)
    (match (eq? x k)
      (#t v)
      (#f (env x)))))

;; -- end Environment --

(def main ([Term term])
  (evalState (eval initial-env term (initial-state 0))))

; end interpreter

(module+ test
  ;; --- Tests for pure part of calculus ---

  (def asMetaPair ([Pair mp])
    (let {Pair l v} mp) (cons l v)
  )

  (def letE (var v cont) (App (Lam var cont) v))

  (require rackunit)
  (check-equal? (main 42) 42)
  (check-equal? (main {Unit}) {Unit})
  (check-equal? (main (Add 1 2)) 3)
  (check-equal? (main (App (Lam "x" "x") 42)) 42)
  (check-equal? (asMetaPair (main (Pair 17 42))) (cons 17 42))
  (check-equal? (asMetaPair (main (Pair (Add 1 2) (Add 17 25)))) (cons 3 42))
  (check-equal? (main (Fst (Pair 17 42))) 17)
  (check-equal? (main (Snd (Pair 17 42))) 42)

  ;; ensuring that my let-sugar works as expected
  (check-equal? (main (letE "x" 1 (letE "x" 2 "x"))) 2)
  (check-equal? (main (letE "x" 1 (letE "y" 2 (Add "x" "y")))) 3)

  (define-syntax (lam* stx)
    (syntax-parse stx
      [(_ (v) body) #'(Lam v body)]
      [(_ (v vs ...+) body) #'(Lam v (lam* (vs ...) body))]))

  (define-syntax (app* stx)
    (syntax-parse stx
      [(_ f v) #'(App f v)]
      [(_ f v vs ...+) #'(app* (App f v) vs ...)]))

  (let*
    ([zero (lam* ("s" "z") "z")]
     [succ (lam* ("n" "s" "z") {App "s" (app* "n" "s" "z")})]
     [two {App succ {App succ zero}}]
     [plus (lam*  ("n" "m" "s" "z") (app* "n" "s" (app* "m" "s" "z")))]
     [pgm (app* plus two two {Lam "n" {Add "n" 1}} 0)])
    (check-equal? (main pgm) 4))

  ;; --- Tests for simple cohandler performing addition on param ---
  (let* (
    ;; Identity operation on configuration and +1 on param
    [algTheory "Monoid"]
    [cohandler (Cohandler algTheory "Increment" "p" "c" (Pair "c" (Add "p" 1)))]
    [cohandle (lambda (t) (Cohandle t cohandler))]
    [incEff (lambda (p) (Coeffect "Increment" p))]

    ;; Effect overriding the one above, identity op on conf and +3 on param
    [cohandlerInner (Cohandler algTheory "Increment" "p" "c" (Pair "c" (Add "p" 3)))]
    [cohandleInner (lambda (t) (Cohandle t cohandlerInner))]
   )
    (check-equal? (main (cohandle 42)) 42)

    (check-equal? (main (cohandle (incEff 0))) 1)
    (check-equal? (main (cohandle (incEff (incEff 0)))) 2)

    ;; Innermost cohandler should be evaluated
    (check-equal? (main (cohandle (cohandleInner (incEff 0)))) 3)
  )

  ;; --- State monad implementation in source language ---

  (let* (
    [algTheory "State"]
    [getCoh (Cohandler algTheory "Get" "_" "c" (Pair "c" "c"))]
    [setCoh (Cohandler algTheory "Set" "nextConf" "_" (Pair "nextConf" {Unit}))]

    [get (lambda (p) (Coeffect "Get" p))]
    [set (lambda (p) (Coeffect "Set" p))]

    [withState (lambda (t) (Cohandle (Cohandle t setCoh) getCoh))]
   )
    (check-equal? (main (withState (set 42))) {Unit})

    (check-equal? (main
      (withState
      (letE "_" (set 42)
      (get {Unit})))
    ) 42)

    (check-equal? (main
      (withState
      (letE "_" (set 1)
      (letE "_" (set 5)
      (get {Unit})))
    )) 5)

    (check-equal? (main
      ;; with a bit of syntactic sugar this language even looks readable!
      (withState
      (letE "_" (set 1)
      (letE "x" (get {Unit})
      (letE "y" (Add "x" 2)
      (letE "_" (set "y")
      (get {Unit})))))
    )) 3)
  )
)
